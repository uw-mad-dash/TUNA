import logging
from fnmatch import fnmatch

from nautilus.benchmarks.common import IsolationLevel
from nautilus.dbms import DBMS, DBMSInfo
from nautilus.utils import run_command


class Redis(DBMS):
    name = 'redis'
    port = 6380
    in_memory = True

    CONF_FILENAME_EXT = 'conf'
    init_db_filepath = ''

    DEFAULT_VERSION = '7.4'
    SUPPORTED_VERSIONS = ['7.2', '7.4']

    # not used but required
    driver_jar_filename = 'jdbc-redis-1.0.0-SNAPSHOT.jar'
    driver_jar_properties = {
        'name': 'jdbc.RedisDriver',
        'subprotocol': 'redis',
        'isolation_level': IsolationLevel.TRANSACTION_REPEATABLE_READ,
        'url_suffix': '?rewriteBatchedStatements=true',
    }

    def __init__(self, config: dict[str, str], info: DBMSInfo) -> None:
        self.logger = logging.getLogger(self._logger_name)
        self.logger.info(f'Redis version: {info.version}')

        version = info.version
        if not version:
            self.logger.info(
                'No Redis version provided -- '
                f'falling back to default [{self.DEFAULT_VERSION}]'
            )
            version = self.DEFAULT_VERSION

        # Check if version is supported
        if not any(fnmatch(version, sv) for sv in self.SUPPORTED_VERSIONS):
            error_msg = (
                f'Redis version {version} not supported :('
                f'Supported versions: {self.SUPPORTED_VERSIONS}'
            )
            self.logger.error(error_msg)
            raise ValueError(error_msg)

        self.version = version

        ## Construct file paths of Redis configurations
        # Default
        filepath = (
            self.conf_dir / f'{self.CONF_DEFAULT_FILE_STEM}.{self.CONF_FILENAME_EXT}'
        )
        self.logger.debug(f'{filepath = }')

        if not filepath.exists() or not filepath.is_file():
            error = f'Redis default config not found: {self.conf_default_filepath}'
            self.logger.error(error)
            raise FileNotFoundError(error)

        self.conf_default_filepath = filepath

        # Load
        filepath = (
            self.conf_dir / f'{self.CONF_LOAD_FILE_STEM}.{self.CONF_FILENAME_EXT}'
        )
        assert (
            filepath.exists() and filepath.is_file()
        ), f'Cross-version config load file not found: {self.conf_load_filepath}'
        self.conf_load_filepath = filepath
        self.logger.info(f'Load config: {self.conf_load_filepath = }')

        # Run -- this file will be created
        major_version = '.'.join(version.split('.')[:2])  # e.g. 8.0.23 -> 8.0
        filepath = (
            self.conf_dir
            / f'{self.CONF_RUN_FILE_STEM}.{major_version}.{self.CONF_FILENAME_EXT}'
        )
        self.conf_run_filepath = self.conf_dir / filepath
        self.logger.info(f'Run config: {self.conf_run_filepath = }')

        super().__init__(config, info)

    def init(self) -> None:
        """Redis init is done implicitly from within docker container"""
        pass

    def get_database_size_gib(self, rounded=True) -> float:
        """Retrieve the size of the database in GiB"""
        return 1

    def run_command(self, command: str, params: list | None = None) -> list:
        """ Run query on database """
        raise NotImplementedError

    def _generate_conf_file(self):
        """Generate Redis configuration file

        The configuration file is generated by appending the default configuration
        NOTE: No check is performed to ensure that the parameters are valid
        """

        def to_valid_value(v):
            if isinstance(v, (str, int, bool)):
                return str(v)
            elif isinstance(v, float):
                return '{0:.3f}'.format(v)
            else:
                error = f'Unexpected type: {type(v)}'
                self.logger.error(error)
                raise RuntimeError(error)

        # Read default configuration
        with open(self.conf_default_filepath, 'r') as f:
            default_conf = f.read()

        if (self.db_config is None) or (self.db_config == {}):
            # Return default configuration
            self.logger.info('Got empty/null configuration. Returning default!')
            return default_conf

        # Append a line for each changed parameter
        default_conf += '\n'
        for k, v in self.db_config.items():
            default_conf += f'{k} {to_valid_value(v)}\n'

        return default_conf
