import logging
from fnmatch import fnmatch
import jaydebeapi

from nautilus.dbms import DBMS, DBMSInfo
from nautilus.benchmarks.common import IsolationLevel

class MySQL(DBMS):
    name = 'mysql'
    port = 3306
    in_memory = False

    driver_jar_filename = 'mysql-connector-j-8.3.0.jar'
    driver_jar_properties = {
        'name': 'com.mysql.jdbc.Driver',
        'subprotocol': 'mysql',
        'isolation_level': IsolationLevel.TRANSACTION_REPEATABLE_READ,
        'url_suffix': '?rewriteBatchedStatements=true',
    }

    CONF_FILENAME_EXT = 'cnf'

    DEFAULT_VERSION = '8.0'
    SUPPORTED_VERSIONS = [
        '5.7', '5.7.*',
        '8.0', '8.0.*',
        '8.1', '8.1.*',
        '8.2', '8.2.*',
        '8.3', '8.3.*',
    ]

    def __init__(self, config: dict[str, str], info: DBMSInfo) -> None:
        self.logger = logging.getLogger(self._logger_name)
        self.logger.info(f'MySQL version: {info.version}')

        version = info.version
        if not version:
            self.logger.info('No MySQL version provided -- '
                        f'falling back to default [{self.DEFAULT_VERSION}]')
            version = self.DEFAULT_VERSION

        # Check if version is supported
        if not any(fnmatch(version, sv) for sv in self.SUPPORTED_VERSIONS):
            error_msg = (f'MySQL version {version} not supported :('
                         f'Supported versions: {self.SUPPORTED_VERSIONS}')
            self.logger.error(error_msg)
            raise ValueError(error_msg)

        self.version = version

        ## Construct file paths of MySQL configurations
        # Default
        filepath = self.conf_dir / f'{self.CONF_DEFAULT_FILE_STEM}.{self.CONF_FILENAME_EXT}'
        if not filepath.exists() or not filepath.is_file():
            error = f'MySQL default config not found: {self.conf_default_filepath}'
            self.logger.error(error)
            raise FileNotFoundError(error)

        self.conf_default_filepath = filepath
        self.logger.debug(f'{self.conf_default_filepath = }')

        # Load
        filepath = self.conf_dir / f'{self.CONF_LOAD_FILE_STEM}.{self.CONF_FILENAME_EXT}'
        assert filepath.exists() and filepath.is_file(), \
                f'Cross-version config load file not found: {self.conf_load_filepath}'
        self.conf_load_filepath = filepath
        self.logger.info(f'Load config: {self.conf_load_filepath = }')

        # Run -- this file will be created
        major_version = '.'.join(version.split('.')[:2]) # e.g. 8.0.23 -> 8.0
        filepath = self.conf_dir / f'{self.CONF_RUN_FILE_STEM}.{major_version}.{self.CONF_FILENAME_EXT}'
        self.conf_run_filepath = self.conf_dir / filepath
        self.logger.info(f'Run config: {self.conf_run_filepath = }')

        super().__init__(config, info)

    def init(self):
        """ Database init is done implicitly from within docker container """
        pass

    def get_database_size_gib(self, rounded=True) -> float:
        """ Retrieve the size of the database in GiB """
        sql_query = f"""
            SELECT table_schema,
            ROUND(SUM(data_length + index_length) / 1024 / 1024 / 1024, 3) "DB Size in GB"
            FROM information_schema.tables  WHERE table_schema='{self.db_name}'
            GROUP BY table_schema;
        """
        try:
            db_size = float(self.run_command(sql_query)[1])
        except Exception as err:
            self.logger.error(f'While retrieving db size: {repr(err)}')
            db_size = float('nan')

        return round(db_size, 3) if rounded else db_size
    
    def run_command(self, command: str, params: list | None = None) -> list:
        """ Run query on database """
        try:
            conn: jaydebeapi.Connection = self.create_connection()
        except Exception as err:
            self.logger.error(f'While attempting to connect to DBMS: {repr(err)}')
            return float('nan')
        finally:
            curs: jaydebeapi.Cursor = conn.cursor()
        
        try:
            curs.execute(f"SELECT pg_database_size('{self.db_name}')")
            result = curs.fetchall()[0]
            return result
        finally:
            curs.close()
            conn.close()

    def _generate_conf_file(self):
        """ Generate MySQL configuration file

        The configuration file is generated by appending the default configuration
        NOTE: No check is performed to ensure that the parameters are valid
        """

        def to_valid_value(v):
            if isinstance(v, (str, int, bool)):
                return str(v)
            elif isinstance(v, float):
                return '{0:.3f}'.format(v)
            else:
                error = f'Unexpected type: {type(v)}'
                self.logger.error(error)
                raise RuntimeError(error)

        # Read default configuration
        with open(self.conf_default_filepath, 'r') as f:
            default_conf = f.read()

        if (self.db_config is None) or (self.db_config == { }):
            # Return default configuration
            self.logger.info('Got empty/null configuration. Returning default!')
            return default_conf

        # Append a line for each changed parameter
        default_conf += '\n'
        for k, v in self.db_config.items():
            default_conf += f'{k} = {to_valid_value(v)}\n'

        return default_conf
